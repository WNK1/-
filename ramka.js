//метрики блока - то есть его отступы / какая т доступная ширина / его отступы слева и сверху и так далее 
const block = document.querySelector('.header__main')

//далее получаем метрики от которых позиционирован наш объект / от род элемента 
//свойство offset offsetLeft offsetTop 

//с помощью ствойства offset получаем родительский элемент  
const rod = block.offsetParent ;
console.log(rod)

//данное свойство нам выведет родительский элемент либо 
//1 применено позиционирование к блоку э
//2 есть теги th td table 
//или же 3 как в нашем случае будет просто body 
 

//получаем позицию  относительно родителя 
const offsetLeft = block.offsetLeft;
const offsetTop = block.offsetTop;
console.log(offsetLeft)
console.log(offsetTop)

//теперь же получим размеры всего объекта 
console.log('размеры всего объекта')
const offsetWidth = block.offsetWidth;
const offsetHeight = block.offsetHeight;
console.log(offsetWidth)
console.log(offsetHeight)

//углубимся в сам элемент и узнаем отступы внутри элемента от внешней части 
console.log('углубимся в сам элемент и узнаем отступы внутри элемента от внешней части ')
const clientTop = block.clientTop;
const clientleft = block.clientLeft;
console.log(clientTop)
console.log(clientleft)



console.log('узнаем ширину и высоту всего блока без рамок и скролла ')
const clientWidth = block.clientWidth;
const clientHieght = block.clientHeight;
console.log(clientWidth)
console.log(clientHieght)

//далее свойства scrollwidght и hight - вернут нам значения высоту и ширину всего контента который скрыт с помощью скролла 

const scrollWidth = block.scrollWidth;
const scrollHeight = block.scrollHeight;
console.log('здесь мы получаем высоту и ширинувсего контента - все что скрыто за скроллом ')
console.log(scrollWidth)
console.log(scrollHeight)


//далее изучим теги scrollLeft / scrollTop - возвращают размеры прокрученной области  - та которая уже прокрученна и срыта скролом
 const scrollTop = block.scrollTop ;
 const scrollleft = block.scrollLeft;

 block.scrollTop = 70; //прописываем без px 
 console.log('scrollLeft / scrollTop - возвращают размеры прокрученной области  - та которая уже прокрученна и срыта скролом')
 console.log(scrollTop)
 console.log(scrollleft)


 //данные теги scrollLeft / scrollTop можно использовать не только для чтения  но и так же мы изначально можем задать им уже прокрученный скролл 
 //просто обращаемся к константе 



 //координаты их получение 
 //относительно окна браузера  
 const elem = document.querySelector('.header__main') //получаем объект  
 const coords = elem.getBoundingClientRect().top;  //далее прописываем данный тег и получаем в констату координаты элемента 
 console.log(coords)

 //так же если нам необходимо получить значение определенной координаты то указываем все точно так же тоько в конце через точку указываем ее например : left 
 //const coords = elem.getBoundingClientRect().left ; //и получим координаты только отступа слево

 //в данном способе мы получаем данные относительно скрола так скажем и  при скроел вверх или вниз данные занчения будут меняться 
 // что бы так не происходило и мы всегда знали на каких координатах распологается элемент относительно главного экрана страницы 
 //добавим колличество прокрученных пикселей к поличеным координатам 
 const absoluteCoords = coords + scrollY;
 console.log(`абсолютные - неизменные координаты сверху , относително главной старницы равны ${absoluteCoords}`)

 









 
 //события в js 
 //обратимся к объекту который хотим задействовать 
 const onclick = document.querySelector('.first-batton')
 //далее обращаемся к константе и через точку указываем событие например onclick 
 onclick.onclick = function (){
    console.log('кнопка была нажата');
 };

 //или же можем сразу же прописать функцию и все определить внутри нее 
 function OnClicks(){
    console.log('кнопка нажата несколько раз ');
 }
 onclick.onclick = OnClicks;//Важно написать без скобок  


 //главный недостаток выше описанного способа что в данном случае нельзя будет поставить сразу несколько обработчиков - они просто перезапишутся  


 //существует более подходящий и удобный метод EventListener 

 //синтаскис следующий 1 прописаваем определенную константу в которой орпеделен элемент после прописываем addEventListener 
 /*(в скобках указываем название события , функцию или если она определенна то ее название {в самой функции доп опции})*/

 const events = document.querySelector('.first-batton') //получаем элемент 
 events.addEventListener('click',function mails(){console.log('кнопка в боевой готовности'),events.removeEventListener('click',mails)})


  //метод removeAddEventListener - существеет для того что бы либо убать действие либо же так сажем отключить слежку за объектом после выполниния события 
 //например как в примере выше сделать так что бы события в консольных логах отобразились 1 раз , а потом это все прекратилось  

 //так же у addEventListener есть опции они указываются либо в строке после указания функции которую нужно выполнить , либо же в отдельной переменной 
 const options = {
    "capture":false,//фаза на которой должен сработать обработчик 
    "once": true,//данный тег при принятие true будет испольнять вункцию remouveEventListener и действия будут выполняться 1 раз / если false то наоборот
    "passive":false,// если true то указывает на то что обработчик никогда не вызовет preventDefault()
 }


 //объект события 
 /*Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия пользователя, 
 такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent. Существует множество различных событий с разным набором информации.
 они впервую очередь созданы для того что бы обработчик можно было более точно понять что произошло */

 //принято называть обект события - event 

 //как всегда определяем объект 
 const target = document.querySelector('.first-batton')

 function logEvents(event){
    //получаем тип события 
    console.log(event.type);

    //объект на котором сработал обработчик - например если бы у нас был span в кнопке то он бы нам его вывел 
    console.log(event.target);

    //объект которому назначен обработчик - в данном случае он назначен кнопке 
    console.log(event.currentTarget);

    //так же можем узнать положение курсора - его позициюпо x,y в момент клика по кнопке 
    console.log(event.clientX)
    console.log(event.clientY)
    //а так же можно узнать все event доступные нам 
    console.log(event)
 }


 target.addEventListener("click",logEvents);

 //всплытие и погружение 
 //условно всплытие это то что нам будет указваться весь путь от первого блока к третьему (или наоборот) если мы нажмем как раз таки на него ( на 3 блок)
 //нам возратиться не только 3 блок а весь путь до него , вообщем не так как мы предпологали 
 const block1 = document.querySelector(".header__text-broder")
 const block2 = document.querySelector(".header__matreshka")
 const block3 = document.querySelector(".header__main")

block1.addEventListener("click",function(event){console.log('клик на 1 уровень')});
block2.addEventListener("click",function(event){
   console.log('клик на 2 уровень') ; 

},{"capture":true})
block3.addEventListener("click",function(event){console.log('клик на 3 уровень');/*event.stopPropagation()/* event.propagation останавливает всплытие дальше элемента*/})
//с помощью выше описаного метода в block3 мы можем прекращать всплытие на любом из уровней , но надо пользоваться данным методом очень осторожно так как могут возникать ошибки

//погружение - возратит и построит нам цепочку на всплытие от элемента на котором и произошло действие 
//для погружения нам достаточно вписать тег capture со значением true - и как раз с помощью этого мы и сможем добиться "погружения" {"capture":true})
//вписывать сразу 2 действия нельзя - они конфликтуют между собой 


//ДЕЛЕГИРОВАНИЕ событий - используется если у нас множество кнопок и прочего на что навешано одно и тоже действие с одним и тем же значением 
/*например на все кнопки навешано показ в консоли УРА 
в таком случае наш хеш на сайте будет перегружаться и что бы сделать оптимизацию используют делегирование */



//1 что мы делаем это мы определяем родительский элемент кнопок и уже на него и будем навешивать события а не как обычно определяем класс кнопки 
const batons1 = document.querySelector('.header__container')
//2 пишем функцию которая должна нам показывать результат - то что мы хотим вывести в консоль 
function pokazat(){
   console.log('кнопку нажали')
}

//3 действием мы пропишем функцию с условием на проверку существования кнопки 
batons1.addEventListener("click", function(event){
   if(event.target.closest('.first-batton')){
      pokazat();
   }
});

//ДЕЙСТВИЯ БРАУЗЕРА ПО УМОЛЧАНИЮ И ИХ ЗАПРЕТ НА ДЕЙСТВИЕ 
//если мы обрабатывем действия в js то нам не нужны стандартные дейсвие , к счастью мы их можем отменить с помощью preventDefault()
const link = document.querySelector('.prevent-default__link')
link.addEventListener("click",function(event){
   console.log('Происходит переход на другую страницу')
   //что бы соответственно отменить переход на другую страницу напищем данную функцию
   event.preventDefault();
})

//ОСНОВНЫЕ СОБЫТИЯ МЫШИ 
//мы можем разделить события на 2 группы - простые и комплексные  
/* простые события - 
   mouseup / mousedown - кнопка мыши отпущена над элементом / кнопка мыши нажата на элемент 
   mouseover / mouseout - курсор мыши появляется над элеметом / уходит с него  
   mousemove - каждое движение мыши над элементом генирирует новое событие 
   contextmenu -  вызывается при попытке открытия контекстного меню 

//комплексные события  - 
click - вызывается при mousedown а хатем при помощи mouseup над одним и тем же элементом если использовалась одна основная кнопка мыши 
dblclick - вызывается даблкликом по элементу */





//используем события мыши для отображения координат курсора на блоке 
const livecoord = document.querySelector('.coord__text')

livecoord.addEventListener("mousemove",function(event){
   livecoord.innerHTML = 
   `coord x = ${event.clientX} <hr> <br>
    coord y = ${event.clientY}`;
});


//mouseenter/mouseleave - это все те же события что и  mouseover / mouseout - курсор мыши появляется над элеметом / уходит с него  
// - но галавное отличие это то что в mouseenter/mouseleave дочерние элементы не вызывают погружения 
// то есть не будут проходить путь и отправлять логи что например элемент ушел с блока - элемент вернулся на блок хотя курсор все время был над блоком
///mouseenter/mouseleave и как раз таки данные события не бурут в расчет дочерние элементы и детектят сам главный блок 

 /* !!!! НО У mouseover / mouseout ЕСТЬ СВОЙ ГЛАВНЫЙ ПЛЮС , ЕСЛИ У НАС БЛОК НАПРИМЕР С ЦИФРАМИ И НАМ НУЖНО ЧТО БЫ КАЖДЫЙ ЭЛЕМЕНТ ВНУТРИ БЛОКА ПРИ НАВЕДЕНИИ НА НЕГО 
 МЕНЯЛ СВОЙ ЦВЕТ ТО ТУТ ПОДОЙДУТ ТОЛЬКО ЭТИ МЕТОДЫ - ТАК КАК ЭТО ДЕЛЕГИРОВАНИЕ */

 